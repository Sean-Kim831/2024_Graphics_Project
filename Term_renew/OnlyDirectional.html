<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>20195123 김동현 - Test</title>
</head>

<body>
    <button id="rollDice">Roll Dice</button>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three/build/three.module.js",
                "three/addons/": "https://unpkg.com/three/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls, spotLight;
        let cells = [];
        let currentPosition = 0;
        const boardSize = 10;
        let isRolling = false;
        let rollingAngle = 0;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xafafaf);

            const aspectRatio = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(90, aspectRatio, 0.001, 1000);
            camera.position.y = 5;
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.maxPolarAngle = Math.PI / 2;

            // Ground cells
            const cellSize = 1;
            const cellMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc });
            for (let x = 0; x < boardSize; x++) {
                for (let z = 0; z < boardSize; z++) {
                    const cellGeometry = new THREE.PlaneGeometry(cellSize, cellSize);
                    const cell = new THREE.Mesh(cellGeometry, cellMaterial);
                    cell.position.set(x - boardSize / 2, 0, z - boardSize / 2);
                    cell.rotation.x = -Math.PI / 2;
                    scene.add(cell);
                    cells.push(cell);
                }
            }

            // Spot light
            spotLight = new THREE.SpotLight(0xffffff);
            spotLight.position.set(5, 10, 5);
            spotLight.angle = Math.PI / 8;
            spotLight.penumbra = 0.5;
            spotLight.castShadow = true;
            scene.add(spotLight);

            window.addEventListener('resize', onWindowResize);

            document.getElementById("rollDice").addEventListener("click", rollDice);
        }

        function rollDice() {
            isRolling = true;
            const diceValue = Math.floor(Math.random() * 6) + 1 + Math.floor(Math.random() * 6) + 1; // 두 개의 주사위
            currentPosition = (currentPosition + diceValue) % cells.length;
            setTimeout(() => {
                highlightCell(currentPosition);
            }, 2000);
        }

        function highlightCell(index) {
            const cell = cells[index];
            spotLight.position.set(cell.position.x, 10, cell.position.z);
            setTimeout(() => {
                isRolling = false;
            }, 2000); // 잠시 후 원래 상태로 돌아가기
        }

        function onWindowResize() {
            const aspectRatio = window.innerWidth / window.innerHeight;
            camera.aspect = aspectRatio;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (!isRolling) {
                rollingAngle += 0.01;
                spotLight.position.set(5 * Math.cos(rollingAngle), 10, 5 * Math.sin(rollingAngle));
            }

            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>
