<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>20195123 김동현 - Test</title>
</head>

<body>
    <script type="x-shader/x-vertex" id="vertexShader">
        varying vec3 vNormal;
        varying vec3 vWorldPosition;

        void main() {
            vNormal = normalize(normalMatrix * normal);
            vec4 worldPosition = modelMatrix * vec4(position, 1.0);
            vWorldPosition = worldPosition.xyz;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    <script type="x-shader/x-fragment" id="fragmentShader">
        precision mediump float;

        varying vec3 vNormal;
        varying vec3 vWorldPosition;
        uniform vec3 uCameraPosition;

        uniform vec3 kAtten, spotDir;
        uniform vec4 lightSrc, lightAmbient, lightDiffuse, lightSpecular;
        uniform vec4 matAmbient, matDiffuse, matSpecular;
        uniform float matShininess, spotExp;
        uniform bool isSpotlight;

        void main() {
            vec3 N = normalize(vNormal);
            vec3 V = normalize(uCameraPosition - vWorldPosition);
            vec3 L;
            float kd, ks, atten = 1.0;
            vec4 diffuse, specular;

            vec3 lightVec = lightSrc.xyz - vWorldPosition;
            L = normalize(lightVec);
            float d = length(lightVec);
            atten = 1.0 / (kAtten[0] + kAtten[1] * d + kAtten[2] * d * d);

            if(isSpotlight) {
                float spotDot = max(dot(normalize(spotDir), -L), 0.0);
                if(spotDot > 0.0) atten *= pow(spotDot, spotExp);
                else atten = 0.0;
            }

            kd = max(dot(L, N), 0.0);
            diffuse = kd * lightDiffuse * matDiffuse;

            vec3 H = normalize(L + V);
            ks = pow(max(dot(N, H), 0.0), matShininess);
            specular = ks * lightSpecular * matSpecular;

            vec4 ambient = lightAmbient * matAmbient;
            gl_FragColor = ambient + atten * (diffuse + specular);
            gl_FragColor.a = 1.0;
        }
    </script>
    <script type="x-shader/x-vertex" id="colorVS">
        void main() {
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    <script type="x-shader/x-fragment" id="colorFS">
        precision mediump float;
        uniform vec4 uColor;

        void main() {
            gl_FragColor = uColor;
        }
    </script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three/build/three.module.js",
                "three/addons/": "https://unpkg.com/three/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let ground;
        var lightSrc = [0.0, 3.0, 0.0, 1.0], angle = 0;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xafafaf);

            const aspectRatio = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(90, aspectRatio, 0.001, 1000)
            camera.position.y = 3;
            camera.position.z = 3;

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.maxPolarAngle = Math.PI / 2;

            const initialCameraPosition = camera.position.toArray();

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    kAtten: { value: [0.2, 0.2, 0.2] },
                    spotDir: { value: [0.0, -1.0, 0.0] },
                    lightSrc: { value: lightSrc },
                    lightAmbient: { value: [0.0, 0.0, 0.0, 1.0] },
                    lightDiffuse: { value: [1.0, 1.0, 1.0, 1.0] },
                    lightSpecular: { value: [1.0, 1.0, 1.0, 1.0] },
                    matAmbient: { value: [1.0, 1.0, 1.0, 1.0] },
                    matDiffuse: { value: [1.0, 1.0, 1.0, 1.0] },
                    matSpecular: { value: [1.0, 1.0, 1.0, 1.0] },
                    matShininess: { value: 100 },
                    spotExp: { value: 5.0 },
                    isSpotlight: { value: true },
                    uCameraPosition: { value: initialCameraPosition },
                },
                vertexShader: document.getElementById("vertexShader").textContent,
                fragmentShader: document.getElementById("fragmentShader").textContent
            });

            // ground
            let groundVertices = new Float32Array(7200); // 800 triangles * 3 vertices * 3D = 7200
            let groundNormals = new Float32Array(7200);
            const groundScale = 10;
            let index = 0;
            for (var x = -groundScale; x < groundScale; x++) {
                for (var z = -groundScale; z < groundScale; z++) {
                    // two triangles
                    groundNormals[index] = 0;
                    groundVertices[index++] = x;
                    groundNormals[index] = 1;
                    groundVertices[index++] = -1;
                    groundNormals[index] = 0;
                    groundVertices[index++] = z;
                    groundNormals[index] = 0;
                    groundVertices[index++] = x;
                    groundNormals[index] = 1;
                    groundVertices[index++] = -1;
                    groundNormals[index] = 0;
                    groundVertices[index++] = z + 1;
                    groundNormals[index] = 0;
                    groundVertices[index++] = x + 1;
                    groundNormals[index] = 1;
                    groundVertices[index++] = -1;
                    groundNormals[index] = 0;
                    groundVertices[index++] = z + 1;

                    groundNormals[index] = 0;
                    groundVertices[index++] = x;
                    groundNormals[index] = 1;
                    groundVertices[index++] = -1;
                    groundNormals[index] = 0;
                    groundVertices[index++] = z;
                    groundNormals[index] = 0;
                    groundVertices[index++] = x + 1;
                    groundNormals[index] = 1;
                    groundVertices[index++] = -1;
                    groundNormals[index] = 0;
                    groundVertices[index++] = z + 1;
                    groundNormals[index] = 0;
                    groundVertices[index++] = x + 1;
                    groundNormals[index] = 1;
                    groundVertices[index++] = -1;
                    groundNormals[index] = 0;
                    groundVertices[index++] = z;
                }
            }

            const groundGeometry = new THREE.BufferGeometry();
            groundGeometry.setAttribute('position', new THREE.Float32BufferAttribute(groundVertices, 3));
            groundGeometry.setAttribute('normal', new THREE.Float32BufferAttribute(groundNormals, 3));
            ground = new THREE.Mesh(groundGeometry, material.clone());
            ground.material.uniforms.matDiffuse.value = [0.8, 0.8, 0.8, 1.0];
            ground.material.uniforms.uCameraPosition.value = initialCameraPosition;
            scene.add(ground);

            const spotLight = new THREE.SpotLight(0xffffff);
            spotLight.position.set(0, 3, 0);
            spotLight.angle = Math.PI / 4;
            spotLight.penumbra = 0.1;
            spotLight.decay = 2;
            spotLight.distance = 50;

            spotLight.castShadow = true;
            spotLight.shadow.mapSize.width = 1024;
            spotLight.shadow.mapSize.height = 1024;
            spotLight.shadow.camera.near = 10;
            spotLight.shadow.camera.far = 200;

            scene.add(spotLight);

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            const aspectRatio = window.innerWidth / window.innerHeight;
            camera.aspect = aspectRatio;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            angle += 0.02;
            lightSrc[0] = 3.0 * Math.sin(angle);
            lightSrc[2] = 3.0 * Math.cos(angle) + 3;

            const currentCameraPosition = camera.position.toArray();
            ground.material.uniforms.lightSrc.value = lightSrc;
            ground.material.uniforms.uCameraPosition.value = currentCameraPosition;

            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>
